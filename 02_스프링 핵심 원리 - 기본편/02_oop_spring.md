# 02. 객체 지향 설계와 스프링

## 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생
- EJB(Enterprice Java Beans): 자바 진영의 표준 기술
- EJB는 어렵고 복잡하고 느리다는 단점이 있음
- POJO
- Spring: EJB 컨테이너 대체, 단순함, 현재 사실상 표준 기술
- Hibernate: EJB 엔티티빈 기술을 대체, JPA 새로운 표준 정의. 
- JPA: 자바 표준. Hibernate가 구현체라면 JPA는 표준 인터페이스

(Spring 역사)
- EJB 문제점 지적
- BeanFactory, ApplicationContext, POJO, IoC, DI
- XML 기반의 설정에서 자바 코드로 설정되도록 변경
- 리액티브 프로그래밍 지원

## 스프링
(스프링 생태계)
- 필수: spring, springboot
- 선택: spring data, spring session, spring security, spring Rest Docs, spring batch, spring cloud

(spring framework)
- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

(스프링 부트)
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd parth(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

(spring 의미)
- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

(spring 핵심 개녕)
- 기술을 만든 이유와 핵심 컨셉
- 스프링은 Java(객체지향 언어) 기반의 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

## 좋은 객체 지향 프로그래밍
(객체 지향 특징)
- 추상화/캡슐화/상속/**다형성**

(객체 지향 프로그래밍)
- 객체 지향 프로그래밍은 컴퓨터 프로그램을 여러 개의 독립된 단위(객체)들의 모임으로 파악하고자 하는 것. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경이 용이**하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용

(다형성: polymorphism)
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
- **역할**과 **구현**으로 세상을 구분
- 인터페이스를 구현한 객체를 인스턴스를 실행 시점에 유연하게 변경 가능
- 클라이언트를 변경하지 않고 서버의 구현 기능을 유연하게 변경 가능

(역할과 구현 분리)
- 역학과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해짐
- 클라이언트는 대상의 역할(인터페이스)만 알면 됨
- 클라이언트는 구현 대상의 내부 구조를 몰라도 됨
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않음
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않음
- 역할은 인터페이스, 구현은 인터페이스를 구현할 클래스/구현 객체
- 객체를 설계할 때 역할과 구현을 분리하고 객체 설계시 역할(인터페이스) 먼저 부여하고 그 역할ㅇ르 수행하는 구현 객체 만들기

(객체의 협력 관계)
- 혼자 있는 객체는 없음
- 클라이언트는 요청하는 객체, 서버는 응답하는 객체
- 클라이언트와 객체 서버는 서로 협력 관계를 가짐

(Java의 다형성)
- 오버라이딩 활용
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능
- 클래스 상속 관계도 다형성, 오버라이딩 적용가능

(한계)
- 역할(인터페이스) 자체가 변하면 클라이언트, 서버 모두에 큰 변경이 발생

(정리)
- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음
- 유연하고 변경이 용이. 확장 가능한 설계
- 클라이언트에 영향을 주지 않고 변경 가능
- **인터페이스를 안정적으로 설계하는 것이 중요**

(스프링과 겍체 지향)
- 다형성이 중요!!
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌
- 스프링의 IoC, DI는 다형성을 활용해서 역할과 구현ㅇ르 편리하게 다룰 수 있도록 지원
- 스프링을 사용하면 레고 조립하듯이 구현을 편리하게 변경 가능

## SOLID(객체지향 설계 원칙)
1) SRP(Single Responsibility Principle): 단일 책임 원칙
- 한 클래스는 하나의 책임만을 가짐
- 중요한 기준은 변경. 변경시 파급효과가 적어야 함

2) **OCP**(Open Closed Principle): 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀있어야 함
- 다형성을 활용해 역할과 구현을 분리
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현

(OCP 문제점)
- 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함
- 다형성을 활용해도 OCP를 지키지 못함
=> 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요(Spring Container 역할)

3) LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 함

4) ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 나음
- 인터페이스가 명확해지고 대체 가능성이 높아짐

5) **DIP**(Dependency Inversion Principle): 의존관계 역전 원칙
- 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안됨
- 구현 클래스에 의존하지 말고 인터페이스에 의존
- 클라이언트 코드가 구현 클래스가 아닌 인터페이스만 바라봄
- Role과 구현은 철저히 분리. Role에 의존

(정리)
- 객체지향의 핵심은 다향성
- 다형성만으로는 구현 객체 변경시 클라이언트 코드로 변경(OCP, DIP 지키는 것 불가)


## 객체지향 설계와 스프링
- 스프링은 DI와 DI Container로 OCP, DIP를 가능하게 지원
- 클라이언트 코드의 변경없이 기능 확장

(정리)
- 모든 설계에 역할과 구현을 분리하자
- 좋은 객체 지향 설계는 Role을 만들어두고 배우는 유연하게 변경할 수 있게 하는 것
- 모든 설계에 인터페이스를 부여하자
- 인터페이스 도입시 추상화라는 비용이 발생. 기능 확장이 불필요하다면 구체 클래스를 직접 사용하고 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것이 방법
